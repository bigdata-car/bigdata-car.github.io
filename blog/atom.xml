<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bigdata-car.github.io/blog</id>
    <title>자동차 산업을 위한 IT기술을 연구 합니다.  Blog</title>
    <updated>2026-01-15T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bigdata-car.github.io/blog"/>
    <subtitle>자동차 산업을 위한 IT기술을 연구 합니다.  Blog</subtitle>
    <icon>https://bigdata-car.github.io/img/kadap.jpg</icon>
    <entry>
        <title type="html"><![CDATA[Welcome]]></title>
        <id>https://bigdata-car.github.io/blog/welcome</id>
        <link href="https://bigdata-car.github.io/blog/welcome"/>
        <updated>2026-01-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Docusaurus blogging features are powered by the blog plugin.]]></summary>
        <content type="html"><![CDATA[<p><a href="https://docusaurus.io/docs/blog" target="_blank" rel="noopener noreferrer">Docusaurus blogging features</a> are powered by the <a href="https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-content-blog" target="_blank" rel="noopener noreferrer">blog plugin</a>.</p>
<p>Simply add Markdown files (or folders) to the <code>blog</code> directory.</p>
<p>Regular blog authors can be added to <code>authors.yml</code>.</p>
<p>The blog post date can be extracted from filenames, such as:</p>
<ul>
<li><code>2019-05-30-welcome.md</code></li>
<li><code>2019-05-30-welcome/index.md</code></li>
</ul>
<p>A blog post folder can be convenient to co-locate blog post images:</p>
<p><img decoding="async" loading="lazy" alt="Docusaurus Plushie" src="https://bigdata-car.github.io/assets/images/docusaurus-plushie-banner-a60f7593abca1e3eef26a9afa244e4fb.jpeg" width="1500" height="500" class="img_ev3q"></p>
<p>The blog supports tags as well!</p>
<p><strong>And if you don't want a blog</strong>: just delete this directory, and use <code>blog: false</code> in your Docusaurus config.</p>
<p>What is this?</p>]]></content>
        <author>
            <name>임헌정</name>
            <uri>https://github.com/bigdata-car</uri>
        </author>
        <category label="KADaP" term="KADaP"/>
        <category label="Hello" term="Hello"/>
        <category label="Docusaurus" term="Docusaurus"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[LLM 정리 5]]></title>
        <id>https://bigdata-car.github.io/blog/LLM 정리 5</id>
        <link href="https://bigdata-car.github.io/blog/LLM 정리 5"/>
        <updated>2024-07-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[2. LLM은 어떻게 동작하는가]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-llm은-어떻게-동작하는가">2. LLM은 어떻게 동작하는가<a class="hash-link" aria-label="Direct link to 2. LLM은 어떻게 동작하는가" title="Direct link to 2. LLM은 어떻게 동작하는가" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%205#2-llm%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80">​</a></h2>
<ul>
<li>
<p>개요에서 언급한 것 처럼 LLM은 이전 토큰 세트를 기반으로 다음 토큰을 예측하도록 훈련되었습니다. 이는 생성기능을 활성화 하는 자동회귀 방식(autoregressive, 현재 생성된 토큰은 다음 토큰을 생성하기 위한 입력으로 거대언어모델에 재입력 됨)을 수행하여 생성을 가능하게 합니다.</p>
</li>
<li>
<p>첫 번째 단계에서 받은 프롬프트를 토큰화 하고 이를 임베딩으로 변환하는 작업이 수행 됩니다. 임베딩은 입력 텍스트의 벡터 표현입니다. 이러한 임베딩은 무작위로 초기화되어 입력 토큰의 비 의미론적인 벡터 형태를 나타냅니다. 그리고, 모델 훈련 과정에서 맥락화되는 학습이 수행됩니다.</p>
</li>
<li>
<p>다음으로, 레이어별 어텐션(attentation) 및 피드포워드 연산을 수행하여 최종적으로 어휘의 각 단어에 숫자 또는 로짓(logit)을 출력하거나(GPT-N, LLaMA 등의 디코더 모델) 의미론적 임베딩을 출력합니다(BERT와 같은 인코더 모델 및 RoBERTa, ELECTRA 등과 같은 변형 모델).</p>
</li>
<li>
<p>마지막으로 디코더 모델의 경우 다음 단계는 각 (정규화되지 않은) 로짓을 (정규화된) 확률 분포(Softmax 함수를 통해)로 변환하여 텍스트에서 다음에 올 단어를 결정하는 것입니다.</p>
</li>
<li>
<p>아래와 같이 단계를 더 자세히 살펴보겠습니다 :</p>
<ol>
<li>
<p><strong>토큰화</strong> :</p>
<ul>
<li>LLM이 처리를 하기 전에 원시 입력 텍스트는 더 작은 단위(종종 하위 단어 또는 단어)로 토큰화 하여 모델이 인식할 수 있는 조각으로 입력을 나눕니다.</li>
<li>모델에는 고정된 어휘목록(vocabulary)이 있습니다. 따라서, 토큰화 단계는 입력이 어휘목록과 일치하는 형식이 되도록 보장하기 때문에 매우 중요합니다.</li>
<li>GPT-3.5 및 GPT-4용 OpenAI 토크나이저는 <a href="https://platform.openai.com/tokenizer" target="_blank" rel="noopener noreferrer">여기</a>에서 찾을 수 있습니다.</li>
<li>자세한 내용은 <a href="https://aman.ai/primers/ai/tokenizer/" target="_blank" rel="noopener noreferrer">토큰화에 대한 입문서</a>를 참조하세요.</li>
</ul>
</li>
<li>
<p><strong>임베딩</strong> :</p>
<ul>
<li>각 토큰은 임베딩 매트릭스를 사용하여 고차원 벡터에 매핑됩니다. 이 벡터 표현은 토큰의 맥락적 의미를 포착하며 모델의 다음 레이어에 입력으로 사용됩니다.</li>
<li>토큰의 순서에 대한 정보를 모델에 제공하기 위해 매핑된 임베딩에 위치 인코딩(positional encoding)이 추가됩니다. 이는 트랜스포머와 같은 모델이 고유한 순서 인식을 갖고 있지 않기 때문에 특히 중요합니다.</li>
</ul>
</li>
<li>
<p><strong>트랜스포머 구조</strong> :</p>
<ul>
<li>대부분의 최신 LLM의 핵심은 트랜스포머 구조입니다.</li>
<li>트랜스포머는 여러 레이어로 구성되어 있으며, 각 레이어에는 두 가지 주요 구성 요소가 있습니다 : multi-head self-attention 메커니즘과 position-wise feed-forward network 입니다.</li>
<li>자기 어텐션 메커니즘(self-attention mechanism)은 각 토큰들이 자신과 관련해 중요성을 갖는 다른 토큰들에게 가중치를 부여할 수 있게 합니다. 이는 본질적으로 주어진 토큰과 관련있는 특정 부분에 대해 모델이 "주의를 기울일" 수 있도록 합니다.</li>
<li>어텐션 연산된 결과는, 각 위치에서 독립적으로 피드포워드 신경망으로 전달됩니다.</li>
<li>자세한 내용은 <a href="https://aman.ai/primers/ai/transformers/" target="_blank" rel="noopener noreferrer">트랜스포머 아키텍처에 대한 입문서</a>를 참조하세요.</li>
</ul>
</li>
<li>
<p><strong>잔차연결 (Residual Connection)</strong> :</p>
<ul>
<li>모델의 각 하위 계층(예: 자기 어텐션 또는 피드포워드 신경망)은 주변에 잔여 연결이 적용된 후 계층 정규화가 수행됩니다. 이는 활성화를 안정화하고 훈련 속도를 높이는 데 도움이 됩니다.</li>
</ul>
</li>
<li>
<p><strong>출력 레이어</strong> :</p>
<ul>
<li>모든 트랜스포머 레이어를 통과한 후, 각 토큰의 최종 표현은 모델의 어휘목록에 있는 각 단어에 대응하는 로짓 벡터로 변환됩니다.</li>
<li>이러한 로짓은 어휘 목록의 각 단어들이 시퀀스의 다음 단어가 될 가능성을 설명합니다.</li>
</ul>
</li>
<li>
<p><strong>확률분포</strong> :</p>
<ul>
<li>로짓을 확률로 변환하기 위해 Softmax 함수가 적용됩니다. 이는 모두 0과 1 사이에 있고 합이 1이 되도록 로짓을 정규화합니다.</li>
<li>어휘 목록의 단어들 중 확률이 가장 높은 단어가 시퀀스의 다음 단어로 선택될 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>디코딩 (Decoding)</strong> :</p>
<ul>
<li>적용되는 상황에 따라 일관되고 문맥에 맞는 시퀀스를 생성하기 위하여, 그리디 디코딩(greedy decoding), 빔 검색(beam search), Top-K 샘플링(top-k sampling)과 같은 다양한 디코딩 전략이 사용됩니다.</li>
<li>자세한 내용은 <a href="https://aman.ai/primers/ai/token-sampling/" target="_blank" rel="noopener noreferrer">토큰 샘플링 방법</a>에 대한 입문서를 참조하세요.</li>
</ul>
</li>
</ol>
</li>
<li>
<p>여러 단계의 프로세스를 통해, LLM은 인간과 유사한 텍스트를 생성하고, 맥락을 이해하고, 프롬프트에 대한 관련 응답이나 완성을 제공할 수 있습니다.</p>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="21-llm-학습-단계">2.1. LLM 학습 단계<a class="hash-link" aria-label="Direct link to 2.1. LLM 학습 단계" title="Direct link to 2.1. LLM 학습 단계" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%205#21-llm-%ED%95%99%EC%8A%B5-%EB%8B%A8%EA%B3%84">​</a></h3>
<ul>
<li>상위 수준에서, LLMs의 훈련에 포함되는 단계는 다음과 같습니다:<!-- -->
<ol>
<li><strong>문서(코퍼스, corpus) 준비</strong> : 뉴스 기사, 소셜 미디어 게시물, 웹 문서 등 대규모 텍스트 데이터 모음을 수집합니다.</li>
<li><strong>토큰화</strong> : 텍스트를 토큰이라고 하는 개별 단어 또는 하위 단어로 분할합니다.</li>
<li><strong>임베딩 생성</strong> : 일반적으로 훈련을 처음 시작할 때 PyTorch의 <a href="https://pytorch.org/docs/stable/generated/torch.nn.Embedding.html" target="_blank" rel="noopener noreferrer"><code>nn.Embedding</code></a> 클래스를 통해 랜덤하게 초기화된 임베딩 테이블을 사용합니다. 또한, Word2Vec, GloVe, FastText 등과 같은 사전 훈련된 임베딩도 사용할 수 있습니다. 이러한 임베딩은 입력 토큰의 맥락화되지 않은 벡터 형식을 나타냅니다.</li>
<li><strong>신경망 훈련</strong> : 입력 토큰에 대한 신경망 모델을 훈련합니다.<!-- -->
<ul>
<li>BERT 및 그 변형과 같은 인코더 모델의 경우 모델은 마스킹된 특정 단어의 전후 맥락(주변 단어)을 예측하는 방법을 학습합니다.</li>
<li>BERT는 특히 마스킹된 단어를 예측하는 마스크드 언어 모델링 작업(Masked Language Modeling task 또는 Cloze task)과 다음 문장 예측 작업으로 훈련되었습니다; <a href="https://aman.ai/primers/ai/bert/" target="_blank" rel="noopener noreferrer">BERT 입문서</a>에 설명되어 있습니다.</li>
<li>GPT-N, LLaMA 등과 같은 디코더 모델의 경우 주어진 이전 토큰들의 맥락을 고려하여 시퀀스의 다음 토큰을 예측하는 방법을 학습합니다.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="22-추론-reasoning">2.2. 추론 (Reasoning)<a class="hash-link" aria-label="Direct link to 2.2. 추론 (Reasoning)" title="Direct link to 2.2. 추론 (Reasoning)" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%205#22-%EC%B6%94%EB%A1%A0-reasoning">​</a></h3>
<ul>
<li>LLM에서 추론이 어떻게 작동하는지 살펴보겠습니다; 우리는 추론을 “증거와 논리를 사용하여 추론하는 능력”으로 정의할 것입니다. <a href="https://arxiv.org/pdf/2302.07842" target="_blank" rel="noopener noreferrer">(source)</a></li>
<li>추론에는 상식적 추론이나 수학적 추론과 같이 다양한 종류가 있습니다.</li>
<li>마찬가지로, 모델에서 추론을 이끌어내는 방법 또한 다양하며 그 중 하나는 여기에서 언급하는 생각의 사슬(chain-of-thought) 프롬프팅 입니다.</li>
<li>추론과 사실적 정보를 분리하여 최종 결과에 대한 기여도를 분석하는 것은 간단한 일이 아니기 때문에, LLM이 최종 예측을 위해 얼마나 많은 추론을 하는지 아직 알 수 없다는 점을 유의하는 것이 중요합니다.</li>
</ul>]]></content>
        <author>
            <name>강병수</name>
            <uri>https://github.com/bigdata-car</uri>
        </author>
        <category label="LLM" term="LLM"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[LLM 정리 4]]></title>
        <id>https://bigdata-car.github.io/blog/LLM 정리 4</id>
        <link href="https://bigdata-car.github.io/blog/LLM 정리 4"/>
        <updated>2024-07-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[2. LLM은 어떻게 동작하는가]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-llm은-어떻게-동작하는가">2. LLM은 어떻게 동작하는가<a class="hash-link" aria-label="Direct link to 2. LLM은 어떻게 동작하는가" title="Direct link to 2. LLM은 어떻게 동작하는가" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%204#2-llm%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80">​</a></h2>
<ul>
<li>
<p>개요에서 언급한 것 처럼 LLM은 이전 토큰 세트를 기반으로 다음 토큰을 예측하도록 훈련되었습니다. 이는 생성기능을 활성화 하는 자동회귀 방식(autoregressive, 현재 생성된 토큰은 다음 토큰을 생성하기 위한 입력으로 거대언어모델에 재입력 됨)을 수행하여 생성을 가능하게 합니다.</p>
</li>
<li>
<p>첫 번째 단계에서 받은 프롬프트를 토큰화 하고 이를 임베딩으로 변환하는 작업이 수행 됩니다. 임베딩은 입력 텍스트의 벡터 표현입니다. 이러한 임베딩은 무작위로 초기화되어 입력 토큰의 비 의미론적인 벡터 형태를 나타냅니다. 그리고, 모델 훈련 과정에서 맥락화되는 학습이 수행됩니다.</p>
</li>
<li>
<p>다음으로, 레이어별 어텐션(attentation) 및 피드포워드 연산을 수행하여 최종적으로 어휘의 각 단어에 숫자 또는 로짓(logit)을 출력하거나(GPT-N, LLaMA 등의 디코더 모델) 의미론적 임베딩을 출력합니다(BERT와 같은 인코더 모델 및 RoBERTa, ELECTRA 등과 같은 변형 모델).</p>
</li>
<li>
<p>마지막으로 디코더 모델의 경우 다음 단계는 각 (정규화되지 않은) 로짓을 (정규화된) 확률 분포(Softmax 함수를 통해)로 변환하여 텍스트에서 다음에 올 단어를 결정하는 것입니다.</p>
</li>
<li>
<p>아래와 같이 단계를 더 자세히 살펴보겠습니다 :</p>
<ol>
<li>
<p><strong>토큰화</strong> :</p>
<ul>
<li>LLM이 처리를 하기 전에 원시 입력 텍스트는 더 작은 단위(종종 하위 단어 또는 단어)로 토큰화 하여 모델이 인식할 수 있는 조각으로 입력을 나눕니다.</li>
<li>모델에는 고정된 어휘목록(vocabulary)이 있습니다. 따라서, 토큰화 단계는 입력이 어휘목록과 일치하는 형식이 되도록 보장하기 때문에 매우 중요합니다.</li>
<li>GPT-3.5 및 GPT-4용 OpenAI 토크나이저는 <a href="https://platform.openai.com/tokenizer" target="_blank" rel="noopener noreferrer">여기</a>에서 찾을 수 있습니다.</li>
<li>자세한 내용은 <a href="https://aman.ai/primers/ai/tokenizer/" target="_blank" rel="noopener noreferrer">토큰화에 대한 입문서</a>를 참조하세요.</li>
</ul>
</li>
<li>
<p><strong>임베딩</strong> :</p>
<ul>
<li>각 토큰은 임베딩 매트릭스를 사용하여 고차원 벡터에 매핑됩니다. 이 벡터 표현은 토큰의 맥락적 의미를 포착하며 모델의 다음 레이어에 입력으로 사용됩니다.</li>
<li>토큰의 순서에 대한 정보를 모델에 제공하기 위해 매핑된 임베딩에 위치 인코딩(positional encoding)이 추가됩니다. 이는 트랜스포머와 같은 모델이 고유한 순서 인식을 갖고 있지 않기 때문에 특히 중요합니다.</li>
</ul>
</li>
<li>
<p><strong>트랜스포머 구조</strong> :</p>
<ul>
<li>대부분의 최신 LLM의 핵심은 트랜스포머 구조입니다.</li>
<li>트랜스포머는 여러 레이어로 구성되어 있으며, 각 레이어에는 두 가지 주요 구성 요소가 있습니다 : multi-head self-attention 메커니즘과 position-wise feed-forward network 입니다.</li>
<li>자기 어텐션 메커니즘(self-attention mechanism)은 각 토큰들이 자신과 관련해 중요성을 갖는 다른 토큰들에게 가중치를 부여할 수 있게 합니다. 이는 본질적으로 주어진 토큰과 관련있는 특정 부분에 대해 모델이 "주의를 기울일" 수 있도록 합니다.</li>
<li>어텐션 연산된 결과는, 각 위치에서 독립적으로 피드포워드 신경망으로 전달됩니다.</li>
<li>자세한 내용은 <a href="https://aman.ai/primers/ai/transformers/" target="_blank" rel="noopener noreferrer">트랜스포머 아키텍처에 대한 입문서</a>를 참조하세요.</li>
</ul>
</li>
<li>
<p><strong>잔차연결 (Residual Connection)</strong> :</p>
<ul>
<li>모델의 각 하위 계층(예: 자기 어텐션 또는 피드포워드 신경망)은 주변에 잔여 연결이 적용된 후 계층 정규화가 수행됩니다. 이는 활성화를 안정화하고 훈련 속도를 높이는 데 도움이 됩니다.</li>
</ul>
</li>
<li>
<p><strong>출력 레이어</strong> :</p>
<ul>
<li>모든 트랜스포머 레이어를 통과한 후, 각 토큰의 최종 표현은 모델의 어휘목록에 있는 각 단어에 대응하는 로짓 벡터로 변환됩니다.</li>
<li>이러한 로짓은 어휘 목록의 각 단어들이 시퀀스의 다음 단어가 될 가능성을 설명합니다.</li>
</ul>
</li>
<li>
<p><strong>확률분포</strong> :</p>
<ul>
<li>로짓을 확률로 변환하기 위해 Softmax 함수가 적용됩니다. 이는 모두 0과 1 사이에 있고 합이 1이 되도록 로짓을 정규화합니다.</li>
<li>어휘 목록의 단어들 중 확률이 가장 높은 단어가 시퀀스의 다음 단어로 선택될 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>디코딩 (Decoding)</strong> :</p>
<ul>
<li>적용되는 상황에 따라 일관되고 문맥에 맞는 시퀀스를 생성하기 위하여, 그리디 디코딩(greedy decoding), 빔 검색(beam search), Top-K 샘플링(top-k sampling)과 같은 다양한 디코딩 전략이 사용됩니다.</li>
<li>자세한 내용은 <a href="https://aman.ai/primers/ai/token-sampling/" target="_blank" rel="noopener noreferrer">토큰 샘플링 방법</a>에 대한 입문서를 참조하세요.</li>
</ul>
</li>
</ol>
</li>
<li>
<p>여러 단계의 프로세스를 통해, LLM은 인간과 유사한 텍스트를 생성하고, 맥락을 이해하고, 프롬프트에 대한 관련 응답이나 완성을 제공할 수 있습니다.</p>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="21-llm-학습-단계">2.1. LLM 학습 단계<a class="hash-link" aria-label="Direct link to 2.1. LLM 학습 단계" title="Direct link to 2.1. LLM 학습 단계" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%204#21-llm-%ED%95%99%EC%8A%B5-%EB%8B%A8%EA%B3%84">​</a></h3>
<ul>
<li>상위 수준에서, LLMs의 훈련에 포함되는 단계는 다음과 같습니다:<!-- -->
<ol>
<li><strong>문서(코퍼스, corpus) 준비</strong> : 뉴스 기사, 소셜 미디어 게시물, 웹 문서 등 대규모 텍스트 데이터 모음을 수집합니다.</li>
<li><strong>토큰화</strong> : 텍스트를 토큰이라고 하는 개별 단어 또는 하위 단어로 분할합니다.</li>
<li><strong>임베딩 생성</strong> : 일반적으로 훈련을 처음 시작할 때 PyTorch의 <a href="https://pytorch.org/docs/stable/generated/torch.nn.Embedding.html" target="_blank" rel="noopener noreferrer"><code>nn.Embedding</code></a> 클래스를 통해 랜덤하게 초기화된 임베딩 테이블을 사용합니다. 또한, Word2Vec, GloVe, FastText 등과 같은 사전 훈련된 임베딩도 사용할 수 있습니다. 이러한 임베딩은 입력 토큰의 맥락화되지 않은 벡터 형식을 나타냅니다.</li>
<li><strong>신경망 훈련</strong> : 입력 토큰에 대한 신경망 모델을 훈련합니다.<!-- -->
<ul>
<li>BERT 및 그 변형과 같은 인코더 모델의 경우 모델은 마스킹된 특정 단어의 전후 맥락(주변 단어)을 예측하는 방법을 학습합니다.</li>
<li>BERT는 특히 마스킹된 단어를 예측하는 마스크드 언어 모델링 작업(Masked Language Modeling task 또는 Cloze task)과 다음 문장 예측 작업으로 훈련되었습니다; <a href="https://aman.ai/primers/ai/bert/" target="_blank" rel="noopener noreferrer">BERT 입문서</a>에 설명되어 있습니다.</li>
<li>GPT-N, LLaMA 등과 같은 디코더 모델의 경우 주어진 이전 토큰들의 맥락을 고려하여 시퀀스의 다음 토큰을 예측하는 방법을 학습합니다.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="22-추론-reasoning">2.2. 추론 (Reasoning)<a class="hash-link" aria-label="Direct link to 2.2. 추론 (Reasoning)" title="Direct link to 2.2. 추론 (Reasoning)" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%204#22-%EC%B6%94%EB%A1%A0-reasoning">​</a></h3>
<ul>
<li>LLM에서 추론이 어떻게 작동하는지 살펴보겠습니다; 우리는 추론을 “증거와 논리를 사용하여 추론하는 능력”으로 정의할 것입니다. <a href="https://arxiv.org/pdf/2302.07842" target="_blank" rel="noopener noreferrer">(source)</a></li>
<li>추론에는 상식적 추론이나 수학적 추론과 같이 다양한 종류가 있습니다.</li>
<li>마찬가지로, 모델에서 추론을 이끌어내는 방법 또한 다양하며 그 중 하나는 여기에서 언급하는 생각의 사슬(chain-of-thought) 프롬프팅 입니다.</li>
<li>추론과 사실적 정보를 분리하여 최종 결과에 대한 기여도를 분석하는 것은 간단한 일이 아니기 때문에, LLM이 최종 예측을 위해 얼마나 많은 추론을 하는지 아직 알 수 없다는 점을 유의하는 것이 중요합니다.</li>
</ul>]]></content>
        <author>
            <name>강병수</name>
            <uri>https://github.com/bigdata-car</uri>
        </author>
        <category label="LLM" term="LLM"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[LLM 정리 3]]></title>
        <id>https://bigdata-car.github.io/blog/LLM 정리 3</id>
        <link href="https://bigdata-car.github.io/blog/LLM 정리 3"/>
        <updated>2024-07-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[2. LLM은 어떻게 동작하는가]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-llm은-어떻게-동작하는가">2. LLM은 어떻게 동작하는가<a class="hash-link" aria-label="Direct link to 2. LLM은 어떻게 동작하는가" title="Direct link to 2. LLM은 어떻게 동작하는가" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%203#2-llm%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80">​</a></h2>
<ul>
<li>
<p>개요에서 언급한 것 처럼 LLM은 이전 토큰 세트를 기반으로 다음 토큰을 예측하도록 훈련되었습니다. 이는 생성기능을 활성화 하는 자동회귀 방식(autoregressive, 현재 생성된 토큰은 다음 토큰을 생성하기 위한 입력으로 거대언어모델에 재입력 됨)을 수행하여 생성을 가능하게 합니다.</p>
</li>
<li>
<p>첫 번째 단계에서 받은 프롬프트를 토큰화 하고 이를 임베딩으로 변환하는 작업이 수행 됩니다. 임베딩은 입력 텍스트의 벡터 표현입니다. 이러한 임베딩은 무작위로 초기화되어 입력 토큰의 비 의미론적인 벡터 형태를 나타냅니다. 그리고, 모델 훈련 과정에서 맥락화되는 학습이 수행됩니다.</p>
</li>
<li>
<p>다음으로, 레이어별 어텐션(attentation) 및 피드포워드 연산을 수행하여 최종적으로 어휘의 각 단어에 숫자 또는 로짓(logit)을 출력하거나(GPT-N, LLaMA 등의 디코더 모델) 의미론적 임베딩을 출력합니다(BERT와 같은 인코더 모델 및 RoBERTa, ELECTRA 등과 같은 변형 모델).</p>
</li>
<li>
<p>마지막으로 디코더 모델의 경우 다음 단계는 각 (정규화되지 않은) 로짓을 (정규화된) 확률 분포(Softmax 함수를 통해)로 변환하여 텍스트에서 다음에 올 단어를 결정하는 것입니다.</p>
</li>
<li>
<p>아래와 같이 단계를 더 자세히 살펴보겠습니다 :</p>
<ol>
<li>
<p><strong>토큰화</strong> :</p>
<ul>
<li>LLM이 처리를 하기 전에 원시 입력 텍스트는 더 작은 단위(종종 하위 단어 또는 단어)로 토큰화 하여 모델이 인식할 수 있는 조각으로 입력을 나눕니다.</li>
<li>모델에는 고정된 어휘목록(vocabulary)이 있습니다. 따라서, 토큰화 단계는 입력이 어휘목록과 일치하는 형식이 되도록 보장하기 때문에 매우 중요합니다.</li>
<li>GPT-3.5 및 GPT-4용 OpenAI 토크나이저는 <a href="https://platform.openai.com/tokenizer" target="_blank" rel="noopener noreferrer">여기</a>에서 찾을 수 있습니다.</li>
<li>자세한 내용은 <a href="https://aman.ai/primers/ai/tokenizer/" target="_blank" rel="noopener noreferrer">토큰화에 대한 입문서</a>를 참조하세요.</li>
</ul>
</li>
<li>
<p><strong>임베딩</strong> :</p>
<ul>
<li>각 토큰은 임베딩 매트릭스를 사용하여 고차원 벡터에 매핑됩니다. 이 벡터 표현은 토큰의 맥락적 의미를 포착하며 모델의 다음 레이어에 입력으로 사용됩니다.</li>
<li>토큰의 순서에 대한 정보를 모델에 제공하기 위해 매핑된 임베딩에 위치 인코딩(positional encoding)이 추가됩니다. 이는 트랜스포머와 같은 모델이 고유한 순서 인식을 갖고 있지 않기 때문에 특히 중요합니다.</li>
</ul>
</li>
<li>
<p><strong>트랜스포머 구조</strong> :</p>
<ul>
<li>대부분의 최신 LLM의 핵심은 트랜스포머 구조입니다.</li>
<li>트랜스포머는 여러 레이어로 구성되어 있으며, 각 레이어에는 두 가지 주요 구성 요소가 있습니다 : multi-head self-attention 메커니즘과 position-wise feed-forward network 입니다.</li>
<li>자기 어텐션 메커니즘(self-attention mechanism)은 각 토큰들이 자신과 관련해 중요성을 갖는 다른 토큰들에게 가중치를 부여할 수 있게 합니다. 이는 본질적으로 주어진 토큰과 관련있는 특정 부분에 대해 모델이 "주의를 기울일" 수 있도록 합니다.</li>
<li>어텐션 연산된 결과는, 각 위치에서 독립적으로 피드포워드 신경망으로 전달됩니다.</li>
<li>자세한 내용은 <a href="https://aman.ai/primers/ai/transformers/" target="_blank" rel="noopener noreferrer">트랜스포머 아키텍처에 대한 입문서</a>를 참조하세요.</li>
</ul>
</li>
<li>
<p><strong>잔차연결 (Residual Connection)</strong> :</p>
<ul>
<li>모델의 각 하위 계층(예: 자기 어텐션 또는 피드포워드 신경망)은 주변에 잔여 연결이 적용된 후 계층 정규화가 수행됩니다. 이는 활성화를 안정화하고 훈련 속도를 높이는 데 도움이 됩니다.</li>
</ul>
</li>
<li>
<p><strong>출력 레이어</strong> :</p>
<ul>
<li>모든 트랜스포머 레이어를 통과한 후, 각 토큰의 최종 표현은 모델의 어휘목록에 있는 각 단어에 대응하는 로짓 벡터로 변환됩니다.</li>
<li>이러한 로짓은 어휘 목록의 각 단어들이 시퀀스의 다음 단어가 될 가능성을 설명합니다.</li>
</ul>
</li>
<li>
<p><strong>확률분포</strong> :</p>
<ul>
<li>로짓을 확률로 변환하기 위해 Softmax 함수가 적용됩니다. 이는 모두 0과 1 사이에 있고 합이 1이 되도록 로짓을 정규화합니다.</li>
<li>어휘 목록의 단어들 중 확률이 가장 높은 단어가 시퀀스의 다음 단어로 선택될 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>디코딩 (Decoding)</strong> :</p>
<ul>
<li>적용되는 상황에 따라 일관되고 문맥에 맞는 시퀀스를 생성하기 위하여, 그리디 디코딩(greedy decoding), 빔 검색(beam search), Top-K 샘플링(top-k sampling)과 같은 다양한 디코딩 전략이 사용됩니다.</li>
<li>자세한 내용은 <a href="https://aman.ai/primers/ai/token-sampling/" target="_blank" rel="noopener noreferrer">토큰 샘플링 방법</a>에 대한 입문서를 참조하세요.</li>
</ul>
</li>
</ol>
</li>
<li>
<p>여러 단계의 프로세스를 통해, LLM은 인간과 유사한 텍스트를 생성하고, 맥락을 이해하고, 프롬프트에 대한 관련 응답이나 완성을 제공할 수 있습니다.</p>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="21-llm-학습-단계">2.1. LLM 학습 단계<a class="hash-link" aria-label="Direct link to 2.1. LLM 학습 단계" title="Direct link to 2.1. LLM 학습 단계" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%203#21-llm-%ED%95%99%EC%8A%B5-%EB%8B%A8%EA%B3%84">​</a></h3>
<ul>
<li>상위 수준에서, LLMs의 훈련에 포함되는 단계는 다음과 같습니다:<!-- -->
<ol>
<li><strong>문서(코퍼스, corpus) 준비</strong> : 뉴스 기사, 소셜 미디어 게시물, 웹 문서 등 대규모 텍스트 데이터 모음을 수집합니다.</li>
<li><strong>토큰화</strong> : 텍스트를 토큰이라고 하는 개별 단어 또는 하위 단어로 분할합니다.</li>
<li><strong>임베딩 생성</strong> : 일반적으로 훈련을 처음 시작할 때 PyTorch의 <a href="https://pytorch.org/docs/stable/generated/torch.nn.Embedding.html" target="_blank" rel="noopener noreferrer"><code>nn.Embedding</code></a> 클래스를 통해 랜덤하게 초기화된 임베딩 테이블을 사용합니다. 또한, Word2Vec, GloVe, FastText 등과 같은 사전 훈련된 임베딩도 사용할 수 있습니다. 이러한 임베딩은 입력 토큰의 맥락화되지 않은 벡터 형식을 나타냅니다.</li>
<li><strong>신경망 훈련</strong> : 입력 토큰에 대한 신경망 모델을 훈련합니다.<!-- -->
<ul>
<li>BERT 및 그 변형과 같은 인코더 모델의 경우 모델은 마스킹된 특정 단어의 전후 맥락(주변 단어)을 예측하는 방법을 학습합니다.</li>
<li>BERT는 특히 마스킹된 단어를 예측하는 마스크드 언어 모델링 작업(Masked Language Modeling task 또는 Cloze task)과 다음 문장 예측 작업으로 훈련되었습니다; <a href="https://aman.ai/primers/ai/bert/" target="_blank" rel="noopener noreferrer">BERT 입문서</a>에 설명되어 있습니다.</li>
<li>GPT-N, LLaMA 등과 같은 디코더 모델의 경우 주어진 이전 토큰들의 맥락을 고려하여 시퀀스의 다음 토큰을 예측하는 방법을 학습합니다.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="22-추론-reasoning">2.2. 추론 (Reasoning)<a class="hash-link" aria-label="Direct link to 2.2. 추론 (Reasoning)" title="Direct link to 2.2. 추론 (Reasoning)" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%203#22-%EC%B6%94%EB%A1%A0-reasoning">​</a></h3>
<ul>
<li>LLM에서 추론이 어떻게 작동하는지 살펴보겠습니다; 우리는 추론을 “증거와 논리를 사용하여 추론하는 능력”으로 정의할 것입니다. <a href="https://arxiv.org/pdf/2302.07842" target="_blank" rel="noopener noreferrer">(source)</a></li>
<li>추론에는 상식적 추론이나 수학적 추론과 같이 다양한 종류가 있습니다.</li>
<li>마찬가지로, 모델에서 추론을 이끌어내는 방법 또한 다양하며 그 중 하나는 여기에서 언급하는 생각의 사슬(chain-of-thought) 프롬프팅 입니다.</li>
<li>추론과 사실적 정보를 분리하여 최종 결과에 대한 기여도를 분석하는 것은 간단한 일이 아니기 때문에, LLM이 최종 예측을 위해 얼마나 많은 추론을 하는지 아직 알 수 없다는 점을 유의하는 것이 중요합니다.</li>
</ul>]]></content>
        <author>
            <name>강병수</name>
            <uri>https://github.com/bigdata-car</uri>
        </author>
        <category label="LLM" term="LLM"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[LLM 정리 1]]></title>
        <id>https://bigdata-car.github.io/blog/LLM 정리 1</id>
        <link href="https://bigdata-car.github.io/blog/LLM 정리 1"/>
        <updated>2024-07-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[0. 개요]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="0-개요">0. 개요<a class="hash-link" aria-label="Direct link to 0. 개요" title="Direct link to 0. 개요" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%201#0-%EA%B0%9C%EC%9A%94">​</a></h2>
<ul>
<li>
<p>LLM(Large Language Model)은 트랜스포머(transformer) 아키텍처를 활용하는 심층 신경망입니다. LLM은 엄청난 양의 비정형 데이터를 비지도 학습한 파운데이션 모델(foundation model)의 한 종류이며 파인튜닝(fine-tuning)을 통해 다향한 종류의 downstream task 모델로 변형될 수 있습니다.</p>
</li>
<li>
<p>트랜스포머 구조는 크게 인코더 모델(encoder 모델)과 디코더 모델(decoder model)로 구성됩니다. 두 모델을 구조적인 측면으로 바라보면 몇 가지 차이점을 제외하고는 거의 동일한 구조를 가지고 있습니다. (자세한 내용은 <a href="https://aman.ai/primers/ai/transformers/#transformer-encoder-and-decoder" target="_blank" rel="noopener noreferrer">Transformer</a> 입문과 <a href="https://aman.ai/primers/ai/autoregressive-vs-autoencoder-models/" target="_blank" rel="noopener noreferrer">Autoregressive vs. Autoencoder Models</a>를 참조하세요)</p>
</li>
<li>
<p>아울러, 생성형 인공지능은 디코더 기반 모델이 주로 사용되고 있기 때문에, 본 글에서는 인코더 모델(예: BERT 및 그 변형) 보다는 디코더 모델(예: GPT-x)에 더 중점을 두려고 합니다. 이후 LLM이라는 용어는 디코더 모델을 지칭하고자 합니다.</p>
</li>
<li>
<p>주어진 텍스트(prompt)가 주어졌을 때, LLM이 본질적으로 하는 일은 해당 시스템이 알고 있는 모든 단어목록(vocabulary - 단어의 부분 또는 토큰)에 대한 확률 분포를 계산하는 것입니다. 단어목록은 사람이 설계하여 모델에 부여하기 때문에 단어목록은 모델마다 다를 수 있으며 GPT-3의 경우 약 50,000개 토큰으로 구성된 단어목록이 있습니다. (<a href="https://aiguide.substack.com/p/on-detecting-whether-text-was-generated" target="_blank" rel="noopener noreferrer">Source</a>)</p>
</li>
<li>
<p>LLM은 여전히 환각현상(hallucination)이나 chain of thought(최근 개선이 있음)같은 수많은 제약 사항을 지니고 있지만, 해당 모델은 통계적 언어 모델링을 수행하도록 학습되었다는 점을 명심하는 것이 중요합니다.</p>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-임베딩embedding">1. 임베딩(Embedding)<a class="hash-link" aria-label="Direct link to 1. 임베딩(Embedding)" title="Direct link to 1. 임베딩(Embedding)" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%201#1-%EC%9E%84%EB%B2%A0%EB%94%A9embedding">​</a></h2>
<ul>
<li>
<p>자연어 처리(NLP)에서의 임베딩은 단어 또는 문장의 의미론적 및 구문론적 속성을 포착하는 단어나 문장의 밀집된 벡터 표현입니다. 이러한 임베딩은 일반적으로 대규모 텍스트 모음을 BERT 및 그 변형, Word2Vec, Glove 또는 FastText와 같은 모델의 학습을 통해 얻을 수 있으며, 텍스트 정보를 기계 학습 알고리즘이 처리할 수 있는 형식으로 변환하는 방법을 제공합니다. 간단히 말해서, 임베딩은 단어의 의미론적 의미(내부적으로 하나 이상의 토큰으로 표시됨) 또는 문장의 의미론적 및 구문론적 속성을 조밀한 저차원 벡터로 표현하여 캡슐화합니다.</p>
</li>
<li>
<p>임베딩은 의미론적(contextualized)과 비 의미론적(non-contextualized)으로 구분됩니다. 의미론적의 경우 “bank”와 같은 다의어 단어는 주변의 문맥에 따라서 “finance” 또는 “river”의 의미를 갖는 임베딩으로 변환되어야 합니다. 따라서 의미론적 임베딩은 입력 토근 주변의 다른 토큰들의 함수로 나타내어 집니다. 반면에 비 의미론적에서 각 토큰들의 임베딩은 주변 문맥과 관계없이 사전학습을 통해 정적으로 얻어지며 downstream 작업에 활용될 수 있습니다.</p>
</li>
<li>
<p>토큰에 대한 임베딩을 얻으려면 각 단어에 대해 훈련된 모델에서 학습된 가중치를 추출합니다. 이러한 가중치는 단어 임베딩을 형성하며, 해당 임베딩은 각 단어의 조밀한 벡터로 표현됩니다.</p>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="11-의미론적-임베딩-vs-비-의미론적-임베딩">1.1. 의미론적 임베딩 vs. 비 의미론적 임베딩<a class="hash-link" aria-label="Direct link to 1.1. 의미론적 임베딩 vs. 비 의미론적 임베딩" title="Direct link to 1.1. 의미론적 임베딩 vs. 비 의미론적 임베딩" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%201#11-%EC%9D%98%EB%AF%B8%EB%A1%A0%EC%A0%81-%EC%9E%84%EB%B2%A0%EB%94%A9-vs-%EB%B9%84-%EC%9D%98%EB%AF%B8%EB%A1%A0%EC%A0%81-%EC%9E%84%EB%B2%A0%EB%94%A9">​</a></h3>
<ul>
<li>BERT (Bidirectional Encoder Representations from Transformers)와 같은 트랜스포머 기반의 인코더 모델들은 의미론적 임베딩을 생성하도록 설계 되었습니다. 각 단어에 적정한 벡터를 할당하는 기존의 단어 임베딩(Word2Vec 또는 GloVe)과는 달리 이러한 모델들은 단어의 문맥(주변 단어들)을 고려합니다. 문맥 안에서 단어들이 어떻게 사용되는지에 따라 동일한 단어도 다른 뜻을 지니기 때문에 이러한 모델은 단어에 대한 더 풍부하고 미묘한 의미를 포착할 수 있습니다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="12-임베딩의-사용-예시">1.2. 임베딩의 사용 예시<a class="hash-link" aria-label="Direct link to 1.2. 임베딩의 사용 예시" title="Direct link to 1.2. 임베딩의 사용 예시" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%201#12-%EC%9E%84%EB%B2%A0%EB%94%A9%EC%9D%98-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C">​</a></h3>
<ul>
<li>임베딩을 통해 특정작업 수행에 필요한 다양한 산술연산을 할수 있습니다 :<!-- -->
<ol>
<li><strong>단어 유사도(Word similarity)</strong> : 두 단어의 임베딩을 비교하여 유사성을 이해할 수 있습니다. 유사성 비교를 위해 코사인 유사도를 주로 사용합니다. 이는 두 벡터사이를 이루는 각도의 코사인 값을 측정하는 방법입니다. 두 벡터 사이에 코사인 값이 높다는 것은 두 단어들의 사용법이나 의미적인 측면에서 유사도가 높다는 것은 나타냅니다.</li>
<li><strong>단어 유추(Word analogy)</strong> : 벡터연산은 단어 유추작업에도 사용할 수 있습니다. 예를 들어 "남자"와 "여자"가 주어지고 이와 유사한 기준으로 왕은 무엇과 대응하는 지를 유추하는 문제가 주어졌을 때 <code>"왕" - "남자" + "여자"</code>의 산술연산을 각 단어에 대응되는 임베딩벡터의 연산을 통해서 <code>"여왕"</code> 이라는 답을 얻을 수 있습니다.</li>
<li><strong>문장 유사도(Sentence similarity)</strong> : 두 문장 간의 유사성을 측정하려면 문장의 총 의미를 캡처하도록 설계된 BERT와 같은 모델에서 생성된 특수 [CLS] 토큰 임베딩을 사용할 수 있습니다.<br>
<!-- -->또는 각 문장에 있는 모든 토큰의 임베딩을 평균화하는 평균 벡터를 만들어 해당 벡터들을 비교할 수 있습니다. 하지만 문장 유사성과 같은 문장 수준 작업의 경우 BERT 모델을 수정한 Sentence-BERT(SBERT)가 더 나은 선택인 경우가 많습니다.<br>
<code>SBERT</code>는 의미 공간에서 직접적으로 비교할 수 있는 문장 임베딩을 생성하도록 특별히 훈련되었으며, 이는 일반적으로 문장 수준 작업에서 더 나은 성능을 제공합니다. <code>SBERT</code>에서는 두 문장이 동시에 모델에 입력되므로 각 문장의 맥락을 다른 문장과 관련하여 이해할 수 있으므로 더 정확한 문장 임베딩이 가능합니다.</li>
</ol>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="13-임베딩을-통한-유사도-검색">1.3. 임베딩을 통한 유사도 검색<a class="hash-link" aria-label="Direct link to 1.3. 임베딩을 통한 유사도 검색" title="Direct link to 1.3. 임베딩을 통한 유사도 검색" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%201#13-%EC%9E%84%EB%B2%A0%EB%94%A9%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%9C%A0%EC%82%AC%EB%8F%84-%EA%B2%80%EC%83%89">​</a></h3>
<ul>
<li>
<p>인코더 모델의 출력으로 의미론적 임베딩을 얻게 됩니다. 두 단어간의 유사성 이해, 단어 유추등과 같은 다양한 작업을 위해 임베딩에 대한 산술연산을 할수 있습니다.</p>
</li>
<li>
<p>단어 유사도 작업에서는 단어들에 대한 각각의 의미론적 임베딩을 사용할 수 있습니다. 반면에 문장 유사도 작업에서는 [CLS] 토근의 아웃풋(output)을 사용할 수 있고 또한 모든 단어 토큰들의 임베딩을 평균화한 임베딩벡터를 사용할 수 있습니다. 하지만 문장 유사도 작업에서 최상의 성능을 얻으려면 Sentence BERT 또는 그 변형 모델들이 선호됩니다.</p>
</li>
<li>
<p>단어/문장 유사도는 두 단어/문장의 의미가 의미적으로 동일한 정도를 측정한 것입니다.</p>
</li>
<li>
<p>다음은 단어/문장 유사도에 대한 가장 일반적인 두 가지 척도입니다.<br>
<!-- -->(두 가지 모두 "거리 척도"는 아닙니다.)</p>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="131-내적-유사도dot-product-similarity">1.3.1. 내적 유사도(Dot Product Similarity)<a class="hash-link" aria-label="Direct link to 1.3.1. 내적 유사도(Dot Product Similarity)" title="Direct link to 1.3.1. 내적 유사도(Dot Product Similarity)" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%201#131-%EB%82%B4%EC%A0%81-%EC%9C%A0%EC%82%AC%EB%8F%84dot-product-similarity">​</a></h4>
<ul>
<li>
<p>두 벡터 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>와 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>의 내적(dot product)은 다음과 같이 정의 됩니다.
</p><p align="center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>⋅</mo><mi>v</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">u \cdot v = ||u|| ||v|| cos\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">∣∣</span><span class="mord mathnormal">u</span><span class="mord">∣∣∣∣</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord">∣∣</span><span class="mord mathnormal">cos</span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span></span></span></span></p><p></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">||v||=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">∣∣</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord">∣∣</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> 일때 내적을 활용한 유사도의 측정을 아래의 그림처럼 나타내면 이해가 쉬울 수 있습니다(참고, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi><mo>=</mo><mfrac><mrow><mi>u</mi><mo>⋅</mo><mi>v</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>u</mi><mo>⋅</mo><mi>v</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">cos\theta = \frac{u \cdot v}{||u|| ||v||} = \frac{u \cdot v}{||u||}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">cos</span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.52em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7051em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">u</span><span class="mord mtight">∣∣∣∣</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="mord mtight">∣∣</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mbin mtight">⋅</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.52em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7051em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">u</span><span class="mord mtight">∣∣</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mbin mtight">⋅</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>). 그림에서 보면 내적은 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>를 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span> 방향으로 사영(projection)시킨 것이며 값의 크기는 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>와 이루는 각도, 그리고 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>의 크기(노름 norm)에 의존합니다.</p>
</li>
</ul>
<p align="center"><img src="https://aman.ai/primers/ai/assets/LLM/dotp.png"></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0</span></span></span></span>일 때, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">cos\theta = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">cos</span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span>이 되고 두 벡터는 동일 선상에 있고 내적은 각 벡터의 크기간의 곱이 됩니다. 그리고 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span></span></span></span>가 직각일 때, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">cos\theta =0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">cos</span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0</span></span></span></span>이 되고 두 벡터는 직교하며 내적은 0이 됩니다. 일반적으로 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">cos\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">cos</span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span></span></span></span>는 두 벡터방향의 유사성을 나타냅니다 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>일 때는 반대 방향을 나타냅니다). 이러한 특징은 차원이 증가해도 보존이 되기 때문에 다차원 공간에서 유사도 측정을 하는데 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">cos\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord mathnormal">cos</span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span></span></span></span>가 중요하게 사용됩니다. 이것이 유사도 측정에 가장 일반적으로 사용하는 이유가 됩니다.</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="기하학적-직관">기하학적 직관<a class="hash-link" aria-label="Direct link to 기하학적 직관" title="Direct link to 기하학적 직관" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%201#%EA%B8%B0%ED%95%98%ED%95%99%EC%A0%81-%EC%A7%81%EA%B4%80">​</a></h5>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>와 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>의 내적은 벡터 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>가 벡터 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>로 사영되고 (반대도 성립) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>의 사영된 크기(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">||u|| cos\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">∣∣</span><span class="mord mathnormal">u</span><span class="mord">∣∣</span><span class="mord mathnormal">cos</span><span class="mord mathnormal" style="margin-right:0.02778em">θ</span></span></span></span>)와 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>의 크기(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">||v||</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">∣∣</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord">∣∣</span></span></span></span>)를 곱한 값으로 나타납니다.</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>를 고정한 상태에서 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>의 가능한 모든 회전을 시각화하면 내적은 다음을 제공합니다.</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>와 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>가 직교할 때 벡터 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>가 벡터 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>로 사영(projection)하면 크기가 0인 벡터가 됨으로 내적은 0이 됩니다. 이것은 직관적으로 유사도가 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">0</span></span></span></span>인 것과 대응됩니다.</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>와 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>가 같은 방향이면 내적은 가장 큰 값 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|u| |v|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">∣</span><span class="mord mathnormal">u</span><span class="mord">∣∣</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord">∣</span></span></span></span>를 갖습니다.</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>와 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>가 반대 방향이면 내적은 가장 작은 값 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi mathvariant="normal">∣</mi><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">- |u| |v|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">−</span><span class="mord">∣</span><span class="mord mathnormal">u</span><span class="mord">∣∣</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord">∣</span></span></span></span>를 갖습니다.</li>
</ul>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>⋅</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u \cdot v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>를 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>와 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>의 크기 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">||u|| ||v||</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">∣∣</span><span class="mord mathnormal">u</span><span class="mord">∣∣∣∣</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord">∣∣</span></span></span></span>로 나누면 범위가 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-1, 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>로 제한되어 스케일이 불변이 되고 이것이 코사인 유사도를 선정하는 이유가 되기도 합니다.</p>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="132-코사인-유사도cosine-similarity">1.3.2. 코사인 유사도(Cosine Similarity)<a class="hash-link" aria-label="Direct link to 1.3.2. 코사인 유사도(Cosine Similarity)" title="Direct link to 1.3.2. 코사인 유사도(Cosine Similarity)" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%201#132-%EC%BD%94%EC%82%AC%EC%9D%B8-%EC%9C%A0%EC%82%AC%EB%8F%84cosine-similarity">​</a></h4>
<p align="center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>u</mi><mo>⋅</mo><mi>v</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><msubsup><mi mathvariant="normal">Σ</mi><mn>1</mn><mi>n</mi></msubsup><msub><mi>u</mi><mi>i</mi></msub><msub><mi>v</mi><mi>i</mi></msub></mrow><mrow><msqrt><mrow><msubsup><mi mathvariant="normal">Σ</mi><mn>1</mn><mi>n</mi></msubsup><msubsup><mi>u</mi><mi>i</mi><mn>2</mn></msubsup></mrow></msqrt><msqrt><mrow><msubsup><mi mathvariant="normal">Σ</mi><mn>1</mn><mi>n</mi></msubsup><msubsup><mi>v</mi><mi>i</mi><mn>2</mn></msubsup></mrow></msqrt></mrow></mfrac></mrow><annotation encoding="application/x-tex">CosineSimilarity(u,v) = \frac{u \cdot v}{||u|| ||v||} = \frac{ \Sigma^{n}_{1} u_i v_i }{ \sqrt{ \Sigma^n_1 u^2_i } \sqrt{ \Sigma^n_1 v^2_i } }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mord mathnormal">os</span><span class="mord mathnormal">in</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal">imi</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em">y</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.2251em;vertical-align:-0.52em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7051em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣∣</span><span class="mord mathnormal mtight">u</span><span class="mord mtight">∣∣∣∣</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="mord mtight">∣∣</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="mbin mtight">⋅</span><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.8568em;vertical-align:-0.8296em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0272em"><span style="top:-2.4702em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0283em"><span class="svg-align" style="top:-3.4286em"><span class="pstrut" style="height:3.4286em"></span><span class="mord mtight" style="padding-left:1.19em"><span class="mord mtight"><span class="mord mtight">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6523em"><span style="top:-2.1885em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span><span style="top:-2.8448em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3115em"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8051em"><span style="top:-2.1777em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-2.8448em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3223em"><span></span></span></span></span></span></span></span></span><span style="top:-3.0003em"><span class="pstrut" style="height:3.4286em"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5429em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.5429em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4282em"><span></span></span></span></span></span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0283em"><span class="svg-align" style="top:-3.4286em"><span class="pstrut" style="height:3.4286em"></span><span class="mord mtight" style="padding-left:1.19em"><span class="mord mtight"><span class="mord mtight">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6523em"><span style="top:-2.1885em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span><span style="top:-2.8448em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3115em"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8051em"><span style="top:-2.1777em;margin-left:-0.0359em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-2.8448em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3223em"><span></span></span></span></span></span></span></span></span><span style="top:-3.0003em"><span class="pstrut" style="height:3.4286em"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.5429em"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.5429em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4282em"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:0.04em"></span></span><span style="top:-3.5102em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385em"><span style="top:-2.214em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-2.931em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathnormal mtight">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em"><span style="top:-2.357em;margin-left:-0.0359em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8296em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<ul>
<li>
<p>여기서,</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>와 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>는 비교하고자 하는 두개의 벡터들 입니다.</li>
<li>연산 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em"></span><span class="mord">⋅</span></span></span></span> 는 내적(dot product)을 의미합니다.</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">||u||</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">∣∣</span><span class="mord mathnormal">u</span><span class="mord">∣∣</span></span></span></span>와 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">||v||</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">∣∣</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord">∣∣</span></span></span></span>는 각 벡터들의 크기 (또는 노름, norm)으로 나타내고 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">n</span></span></span></span>은 벡터의 차원을 나타냅니다.</li>
</ul>
</li>
<li>
<p>앞서 언급을 했지만 길이 정규화 부분(즉, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>⋅</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u \cdot v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>를 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal">u</span></span></span></span>와 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em"></span><span class="mord mathnormal" style="margin-right:0.03588em">v</span></span></span></span>의 크기 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>v</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">||u|| ||v||</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">∣∣</span><span class="mord mathnormal">u</span><span class="mord">∣∣∣∣</span><span class="mord mathnormal" style="margin-right:0.03588em">v</span><span class="mord">∣∣</span></span></span></span>로 나눔)은 범위를 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-1,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>로 제한하여 크기가 변하지 않게 만듭니다.</p>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="133-코사인-유사도-vs-내적-유사도">1.3.3. 코사인 유사도 vs. 내적 유사도<a class="hash-link" aria-label="Direct link to 1.3.3. 코사인 유사도 vs. 내적 유사도" title="Direct link to 1.3.3. 코사인 유사도 vs. 내적 유사도" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%201#133-%EC%BD%94%EC%82%AC%EC%9D%B8-%EC%9C%A0%EC%82%AC%EB%8F%84-vs-%EB%82%B4%EC%A0%81-%EC%9C%A0%EC%82%AC%EB%8F%84">​</a></h4>
<ul>
<li>
<p>코사인 유사도와 내적 유사도는 모두 텍스트 문서, 사용자 선호도 등을 나타낼 수 있는 벡터 간의 유사성을 결정하는 데 사용되는 기술입니다. 둘 사이의 선택은 특정 사용 사례와 원하는 속성에 따라 달라집니다. 다음은 내적 유사도에 비해 코사인 유사도가 얻을 수 있는 장점을 비교한 것입니다.</p>
<ul>
<li>
<p><strong>크기 정규화(Magnitude Normalization)</strong> : 코사인 유사도는 크기를 무시하고 두 벡터 사이의 각도만 고려합니다. 이는 길이가 서로 다른 문서나 크기가 유사성을 나타내지 않는 벡터를 비교할 때 특히 유용합니다. 반면에 내적 유사도는 벡터의 크기에 영향을 받습니다. 특정 용어에 대한 언급이 많은 긴 문서는 관련 콘텐츠의 비율이 낮더라도 다른 문서와 높은 내적을 가질 수 있습니다. 동일한 크기를 갖도록 데이터를 정규화하면 두 데이터를 구별할 수 없습니다. 때로는 벡터의 크기를 무시하는 것이 바람직할 때가 있고 이런 경우는 코사인 유사도가 좋은 선택이 될 수 있습니다. 하지만 벡터의 크기가 중요한 역할을 한다면 내적 유사도가 더 좋을 것입니다. 다른 말로 하면 코사인 유사도는 크기를 정규화한 (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\in [0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>) 벡터들의 단순한 내적으로 생각할 수 있습니다. 코사인 유사도는 크기가 불변임으로 자연스럽게 다양한 데이터 샘플에(즉, 다양한 길이) 적용될 수 있기 때문에 선호됩니다. 예를 들어 두 개의 문서 세트가 있고 각 세트 내에서 유사성을 계산한다고 가정해 보겠습니다. 그리고 각 세트 내의 문서의 내용은 유사하지만 세트 #1 문서는 세트 #2 문서보다 짧다고 가정하겠습니다. 이때 세트 #1, #2는 임베딩/특징의 크기가 다르게 나타날 수 있고 내적 유사도는 다른 값을 생성하지만 코사인 유사도는 비슷한 값을 생성합니다 (길이가 정규화 되었기 때문). 반면에, 일반 내적은 연산이 적기 때문에 (길이 정규화가 없음) "저렴" 합니다(복잡성과 구현 측면).</p>
</li>
<li>
<p><strong>제한된 값(Bound Values)</strong> : 코사인 유사도는 음수가 아닌 차원을 가진 벡터에 대해 -1과 1 사이의 값을 반환하고, 특히 방향이 같은 모든 벡터들에 대해 0과 1 사이의 값을 반환합니다 (문서의 TF-IDF 표현의 경우처럼). 이런 제한된 특성은 해석을 더 쉽게 할수 있습니다. 내적 유사도는 값의 범위가 음의 무한대에서 양의 무한대이기 때문에 정규화 또는 임계값 설정을 더 어렵게 할수 있습니다.</p>
</li>
<li>
<p><strong>높은 차원에서의 견고함(Robustness in High Dimensions)</strong> : 차원이 높은 경우 대다수의 벡터들은 거의 직교에 가까운 경향을 나타내고 이는 내적을 하면 거의 0에 가까워짐을 의미한다. 하지만 코사인 유사도는 여전히 의미 있는 차이값을 제공한다. 내적은 각 차원에 따라서 그 값이 매우 민감하고 특히, 차원이 높은 경우 그 영향을 더 많이 받습니다. 벡터가 음수가 아니고 크기가 텍스트 길이에 영향을 받을 수 있는 TF-IDF와 같은 모델로 텍스트를 표현할 때 코사인 유사도가 더 적합합니다.</p>
</li>
<li>
<p><strong>일반적인 사용 사례(Common Use Cases)</strong> : 코사인 유사도는 텍스트 분석, 정보 검색 및 추천 시스템 영역에서의 효율성 때문에 해당 영역들에서 광범위하게 사용됩니다. 내적 유사도는 고유한 장점이 있지만 추가적인 정규화 없이는 이러한 사용 사례에 적합하지 않을 수 있습니다.</p>
</li>
<li>
<p><strong>직관성(Intuitiveness)</strong> : 많은 시나리오에서 각도 측면에서 생각하는 것이 원시 투영을 고려하는 것보다 더 직관적일 수 있습니다. 예를 들어, 두 벡터가 크기에 관계없이 정확히 동일한 방향을 가리키는 경우 코사인 유사도는 1이며 이는 완벽한 유사성을 나타냅니다.</p>
</li>
<li>
<p><strong>중심계산(Centroid Calculation)</strong> : 클러스터링과 같이 여러 벡터들의 중심(평균)을 계산하려고 할 때 중심은 코사인 유사도 하에서 의미 있는 상태로 유지됩니다. 벡터의 평균을 낸 다음 다른 벡터와 코사인 유사도를 사용하여 비교하면 벡터가 "평균" 벡터와 얼마나 유사한지를 측정할 수 있습니다. 내적 유사도의 경우는 반드시 그런 것은 아닙니다. 이러한 장점에도 불구하고 일부 응용 프로그램(특히 신경망과 딥러닝 분야에서는) 계산 속성과 학습된 임베딩의 특성 때문에 원시 내적(때로 정규화 단계가 뒤따름)이 선호된다는 사실을 주목할 가치가 있습니다. 따라서 위의 측정방법 중 선택을 할 때는 항상 특정 응용 프로그램과 데이터 속성을 고려해야 합니다.</p>
</li>
</ul>
</li>
</ul>]]></content>
        <author>
            <name>강병수</name>
            <uri>https://github.com/bigdata-car</uri>
        </author>
        <category label="LLM" term="LLM"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[LLM 정리 2]]></title>
        <id>https://bigdata-car.github.io/blog/LLM 정리 2</id>
        <link href="https://bigdata-car.github.io/blog/LLM 정리 2"/>
        <updated>2024-07-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[2. LLM은 어떻게 동작하는가]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-llm은-어떻게-동작하는가">2. LLM은 어떻게 동작하는가<a class="hash-link" aria-label="Direct link to 2. LLM은 어떻게 동작하는가" title="Direct link to 2. LLM은 어떻게 동작하는가" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%202#2-llm%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80">​</a></h2>
<ul>
<li>
<p>개요에서 언급한 것 처럼 LLM은 이전 토큰 세트를 기반으로 다음 토큰을 예측하도록 훈련되었습니다. 이는 생성기능을 활성화 하는 자동회귀 방식(autoregressive, 현재 생성된 토큰은 다음 토큰을 생성하기 위한 입력으로 거대언어모델에 재입력 됨)을 수행하여 생성을 가능하게 합니다.</p>
</li>
<li>
<p>첫 번째 단계에서 받은 프롬프트를 토큰화 하고 이를 임베딩으로 변환하는 작업이 수행 됩니다. 임베딩은 입력 텍스트의 벡터 표현입니다. 이러한 임베딩은 무작위로 초기화되어 입력 토큰의 비 의미론적인 벡터 형태를 나타냅니다. 그리고, 모델 훈련 과정에서 맥락화되는 학습이 수행됩니다.</p>
</li>
<li>
<p>다음으로, 레이어별 어텐션(attentation) 및 피드포워드 연산을 수행하여 최종적으로 어휘의 각 단어에 숫자 또는 로짓(logit)을 출력하거나(GPT-N, LLaMA 등의 디코더 모델) 의미론적 임베딩을 출력합니다(BERT와 같은 인코더 모델 및 RoBERTa, ELECTRA 등과 같은 변형 모델).</p>
</li>
<li>
<p>마지막으로 디코더 모델의 경우 다음 단계는 각 (정규화되지 않은) 로짓을 (정규화된) 확률 분포(Softmax 함수를 통해)로 변환하여 텍스트에서 다음에 올 단어를 결정하는 것입니다.</p>
</li>
<li>
<p>아래와 같이 단계를 더 자세히 살펴보겠습니다 :</p>
<ol>
<li>
<p><strong>토큰화</strong> :</p>
<ul>
<li>LLM이 처리를 하기 전에 원시 입력 텍스트는 더 작은 단위(종종 하위 단어 또는 단어)로 토큰화 하여 모델이 인식할 수 있는 조각으로 입력을 나눕니다.</li>
<li>모델에는 고정된 어휘목록(vocabulary)이 있습니다. 따라서, 토큰화 단계는 입력이 어휘목록과 일치하는 형식이 되도록 보장하기 때문에 매우 중요합니다.</li>
<li>GPT-3.5 및 GPT-4용 OpenAI 토크나이저는 <a href="https://platform.openai.com/tokenizer" target="_blank" rel="noopener noreferrer">여기</a>에서 찾을 수 있습니다.</li>
<li>자세한 내용은 <a href="https://aman.ai/primers/ai/tokenizer/" target="_blank" rel="noopener noreferrer">토큰화에 대한 입문서</a>를 참조하세요.</li>
</ul>
</li>
<li>
<p><strong>임베딩</strong> :</p>
<ul>
<li>각 토큰은 임베딩 매트릭스를 사용하여 고차원 벡터에 매핑됩니다. 이 벡터 표현은 토큰의 맥락적 의미를 포착하며 모델의 다음 레이어에 입력으로 사용됩니다.</li>
<li>토큰의 순서에 대한 정보를 모델에 제공하기 위해 매핑된 임베딩에 위치 인코딩(positional encoding)이 추가됩니다. 이는 트랜스포머와 같은 모델이 고유한 순서 인식을 갖고 있지 않기 때문에 특히 중요합니다.</li>
</ul>
</li>
<li>
<p><strong>트랜스포머 구조</strong> :</p>
<ul>
<li>대부분의 최신 LLM의 핵심은 트랜스포머 구조입니다.</li>
<li>트랜스포머는 여러 레이어로 구성되어 있으며, 각 레이어에는 두 가지 주요 구성 요소가 있습니다 : multi-head self-attention 메커니즘과 position-wise feed-forward network 입니다.</li>
<li>자기 어텐션 메커니즘(self-attention mechanism)은 각 토큰들이 자신과 관련해 중요성을 갖는 다른 토큰들에게 가중치를 부여할 수 있게 합니다. 이는 본질적으로 주어진 토큰과 관련있는 특정 부분에 대해 모델이 "주의를 기울일" 수 있도록 합니다.</li>
<li>어텐션 연산된 결과는, 각 위치에서 독립적으로 피드포워드 신경망으로 전달됩니다.</li>
<li>자세한 내용은 <a href="https://aman.ai/primers/ai/transformers/" target="_blank" rel="noopener noreferrer">트랜스포머 아키텍처에 대한 입문서</a>를 참조하세요.</li>
</ul>
</li>
<li>
<p><strong>잔차연결 (Residual Connection)</strong> :</p>
<ul>
<li>모델의 각 하위 계층(예: 자기 어텐션 또는 피드포워드 신경망)은 주변에 잔여 연결이 적용된 후 계층 정규화가 수행됩니다. 이는 활성화를 안정화하고 훈련 속도를 높이는 데 도움이 됩니다.</li>
</ul>
</li>
<li>
<p><strong>출력 레이어</strong> :</p>
<ul>
<li>모든 트랜스포머 레이어를 통과한 후, 각 토큰의 최종 표현은 모델의 어휘목록에 있는 각 단어에 대응하는 로짓 벡터로 변환됩니다.</li>
<li>이러한 로짓은 어휘 목록의 각 단어들이 시퀀스의 다음 단어가 될 가능성을 설명합니다.</li>
</ul>
</li>
<li>
<p><strong>확률분포</strong> :</p>
<ul>
<li>로짓을 확률로 변환하기 위해 Softmax 함수가 적용됩니다. 이는 모두 0과 1 사이에 있고 합이 1이 되도록 로짓을 정규화합니다.</li>
<li>어휘 목록의 단어들 중 확률이 가장 높은 단어가 시퀀스의 다음 단어로 선택될 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>디코딩 (Decoding)</strong> :</p>
<ul>
<li>적용되는 상황에 따라 일관되고 문맥에 맞는 시퀀스를 생성하기 위하여, 그리디 디코딩(greedy decoding), 빔 검색(beam search), Top-K 샘플링(top-k sampling)과 같은 다양한 디코딩 전략이 사용됩니다.</li>
<li>자세한 내용은 <a href="https://aman.ai/primers/ai/token-sampling/" target="_blank" rel="noopener noreferrer">토큰 샘플링 방법</a>에 대한 입문서를 참조하세요.</li>
</ul>
</li>
</ol>
</li>
<li>
<p>여러 단계의 프로세스를 통해, LLM은 인간과 유사한 텍스트를 생성하고, 맥락을 이해하고, 프롬프트에 대한 관련 응답이나 완성을 제공할 수 있습니다.</p>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="21-llm-학습-단계">2.1. LLM 학습 단계<a class="hash-link" aria-label="Direct link to 2.1. LLM 학습 단계" title="Direct link to 2.1. LLM 학습 단계" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%202#21-llm-%ED%95%99%EC%8A%B5-%EB%8B%A8%EA%B3%84">​</a></h3>
<ul>
<li>상위 수준에서, LLMs의 훈련에 포함되는 단계는 다음과 같습니다:<!-- -->
<ol>
<li><strong>문서(코퍼스, corpus) 준비</strong> : 뉴스 기사, 소셜 미디어 게시물, 웹 문서 등 대규모 텍스트 데이터 모음을 수집합니다.</li>
<li><strong>토큰화</strong> : 텍스트를 토큰이라고 하는 개별 단어 또는 하위 단어로 분할합니다.</li>
<li><strong>임베딩 생성</strong> : 일반적으로 훈련을 처음 시작할 때 PyTorch의 <a href="https://pytorch.org/docs/stable/generated/torch.nn.Embedding.html" target="_blank" rel="noopener noreferrer"><code>nn.Embedding</code></a> 클래스를 통해 랜덤하게 초기화된 임베딩 테이블을 사용합니다. 또한, Word2Vec, GloVe, FastText 등과 같은 사전 훈련된 임베딩도 사용할 수 있습니다. 이러한 임베딩은 입력 토큰의 맥락화되지 않은 벡터 형식을 나타냅니다.</li>
<li><strong>신경망 훈련</strong> : 입력 토큰에 대한 신경망 모델을 훈련합니다.<!-- -->
<ul>
<li>BERT 및 그 변형과 같은 인코더 모델의 경우 모델은 마스킹된 특정 단어의 전후 맥락(주변 단어)을 예측하는 방법을 학습합니다.</li>
<li>BERT는 특히 마스킹된 단어를 예측하는 마스크드 언어 모델링 작업(Masked Language Modeling task 또는 Cloze task)과 다음 문장 예측 작업으로 훈련되었습니다; <a href="https://aman.ai/primers/ai/bert/" target="_blank" rel="noopener noreferrer">BERT 입문서</a>에 설명되어 있습니다.</li>
<li>GPT-N, LLaMA 등과 같은 디코더 모델의 경우 주어진 이전 토큰들의 맥락을 고려하여 시퀀스의 다음 토큰을 예측하는 방법을 학습합니다.</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="22-추론-reasoning">2.2. 추론 (Reasoning)<a class="hash-link" aria-label="Direct link to 2.2. 추론 (Reasoning)" title="Direct link to 2.2. 추론 (Reasoning)" href="https://bigdata-car.github.io/blog/LLM%20%EC%A0%95%EB%A6%AC%202#22-%EC%B6%94%EB%A1%A0-reasoning">​</a></h3>
<ul>
<li>LLM에서 추론이 어떻게 작동하는지 살펴보겠습니다; 우리는 추론을 “증거와 논리를 사용하여 추론하는 능력”으로 정의할 것입니다. <a href="https://arxiv.org/pdf/2302.07842" target="_blank" rel="noopener noreferrer">(source)</a></li>
<li>추론에는 상식적 추론이나 수학적 추론과 같이 다양한 종류가 있습니다.</li>
<li>마찬가지로, 모델에서 추론을 이끌어내는 방법 또한 다양하며 그 중 하나는 여기에서 언급하는 생각의 사슬(chain-of-thought) 프롬프팅 입니다.</li>
<li>추론과 사실적 정보를 분리하여 최종 결과에 대한 기여도를 분석하는 것은 간단한 일이 아니기 때문에, LLM이 최종 예측을 위해 얼마나 많은 추론을 하는지 아직 알 수 없다는 점을 유의하는 것이 중요합니다.</li>
</ul>]]></content>
        <author>
            <name>강병수</name>
            <uri>https://github.com/bigdata-car</uri>
        </author>
        <category label="LLM" term="LLM"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[LLM 정리 0]]></title>
        <id>https://bigdata-car.github.io/blog/LLM 정리 0</id>
        <link href="https://bigdata-car.github.io/blog/LLM 정리 0"/>
        <updated>2024-06-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Blog posts support Docusaurus Markdown features, such as MDX.]]></summary>
        <content type="html"><![CDATA[<p>Blog posts support <a href="https://docusaurus.io/docs/markdown-features" target="_blank" rel="noopener noreferrer">Docusaurus Markdown features</a>, such as <a href="https://mdxjs.com/" target="_blank" rel="noopener noreferrer">MDX</a>.</p>
<div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</div><div class="admonitionContent_BuS1"><p>Use the power of React to create interactive blog posts.</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain">button onClick</span><span class="token operator" style="color:#393A34">=</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token arrow operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">alert</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">'button clicked!'</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">}</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token maybe-class-name">Click</span><span class="token plain"> me</span><span class="token operator" style="color:#393A34">!</span><span class="token operator" style="color:#393A34">&lt;</span><span class="token operator" style="color:#393A34">/</span><span class="token plain">button</span><span class="token operator" style="color:#393A34">&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><button>Click me!</button></div></div>]]></content>
        <author>
            <name>강병수</name>
            <uri>https://github.com/bigdata-car</uri>
        </author>
    </entry>
</feed>